package solution;

import internal.Environment;
import java.util.Stack;


public class ProcessPhilosophers implements MutexProcess {
    private final Environment env;
    private final boolean[] edge_from;  // Для каждого pid (= номера процесса) храним, правда ли ИЗ нас В него направлено ребро
                                        // (в лекции мы называли это, что "мы владеем ребром")
    private final boolean[] logic_reversed;  // Так же для каждого pid храним, развёрнуто ли (логически) это ребро (это имеет
                                             // смысл только для рёбер, которыми мы владеем (про те, что не владеем, мы не можем сказать,
                                             // развёрнуты ли они логически - ведь они просто чужие, и не нам это решать)...
                                             // если значение = да, то честное направление (которое воплотится, если кто-то
                                             // попросит у нас это ребро) = инвертированное значение от edge_from[pid])
    private final boolean[] is_requested;  // Для каждого ребра запоминаем, запросили ли мы его уже (чтобы нам его дали
                                           // для того, чтобы попасть cs) - важно чтоыб повторно не просить
    private final Stack<Integer> requests = new Stack<>();  // Список процессов, которые хотят получить наше ребро
    private String log;  // На всякий случай (для отладки) добавляем log


    public ProcessPhilosophers(Environment env) {
        this.env = env;
        int n = env.getNumberOfProcesses();  // число процессов -> далее все массивы индексируются от 1 до n

        edge_from = new boolean[n+1];
        for (int pid = 1; pid <= n; pid ++)  // изначально все рёбра направлены из меньшего pid в бОльший
            edge_from[pid] = pid > env.getProcessId();  // поэтому вcе рёбра для pid, которые больше нашего, направлены ИЗ нас
                                           // (что храним в edge_from по нашему собственному pid - не важно, это не используем)
        logic_reversed = new boolean[n+1];
        for (int pid = 1; pid <= n; pid ++)
            logic_reversed[pid] = true;  // изначально все рёбра считаем логически перевёрнутыми, чтобы желающий их
                                         // процесс мог их сразу получить
        is_requested = new boolean[n+1];  // тут инициализировать значения не нужно, ими займёмся только, когда захотим в cs
        log = "=== LOG: Наш pid = " + env.getProcessId() + ", всего процессов: " + env.getNumberOfProcesses() + " ===\n";
    }


    // Функция, которая пытается войти в критическую секцию (вызываем только там, где мы уверены, что хотим в cs):
    private void try_to_cs() {
        boolean cannot = false;

        for (int pid = 1; pid <= env.getNumberOfProcesses(); pid ++) {
            if (pid == env.getProcessId())  // проходимся по всем процессам (кроме своего)
                continue;
            if (!edge_from[pid]) {  // если есть хоть одно НЕ наше ребро, значит войти уже не получится
                cannot = true;  // устанавливаем флаг, что пока войти не можем
                if (!is_requested[pid]) {  // и если ребро ещё не запрашивали,
                    env.send(pid, "need_edge");
                    is_requested[pid] = true;  // запрашиваем и запоминаем
                    log += "---> send: need_edge\n";
                }
            }
        }

        if (cannot)  // если пока не можем войти, то просто выходим
            return;

        for (int pid = 1; pid <= env.getNumberOfProcesses(); pid ++)  // если же можем войти, значит все рёбра - наши
            logic_reversed[pid] = false;  // (если даже есть те, что логически перевёрнуты - не важно, их
                                          // сейчас втихаря обратно делаем своими - ведь всё равно их никто не просил,
                                          // раз они до сих пор наши)
        env.lock();  // и наконец заходим
        log += "  ! Вход в cs: [...\n";
    }


    // Функция, которая вызывается у процесса, если ему пришло сообщение:
    @Override
    public void onMessage(int sourcePid, Object message) {
        log += "<--- get from: " + sourcePid + ", msg: " + message + "\n";

        if (message.equals("need_edge")) {  // Если у нас просят дать ребро, такое может быть только, если ребро принадлежит нам:
            // assert edge_from[sourcePid]: "У нас просят ребро, которое и так не наше\n" + log;  // этот assert обязан был бы,
            // проходить, если бы был FIFO... но, так как FIFO нет, то вполне возможнп такая ситуация:
            // процесс "2" захотел в cs (изначально ребро принадлежит "1") и попросил "1" дать ребро -> тот овтетил ok
            // и стал считать, что ребро теперь принадлежит "2"; затем сам "1" тоже захотел в cs и, так как он считает
            // владельцем ребра "2", то он направил ему запрос; но из-за отсутствия FIFO, этот запрос от "1" мог дойти
            // до "2" раньше, чем ok -> "2" не получал ok, а значит всё ещё считает владельцем ребра "1", но тут от негоэ
            // прилетел запрос на это ребро... наш бы assert упал!
            // на самом деле, вроде как, этот пример - единственная возможная проблема из-за отсутствия FIFO, суть
            // которой такая: у нас просят ребро, которое мы запрашивали ранее, но ok на которое нам ещё не дошёл;
            // если бы ok пришёл бы раньше, мы бы просто стали считать это ребро своим (и не логически развёрнутым), а
            // потому такой запрос просто бы добавили в очередь (и не отдали бы ребро, то есть пока бы не ответили ok,
            // так как нам самим это ребро нужно)... так давайте так и сейчас поступим (ведь ok рано или поздно мы
            // всё равно получим и станем считать ребро своим -> авансом будем считать ребро своим и сейчас)
            if (!edge_from[sourcePid]) {
                requests.add(sourcePid);  // если ребра нет, значит мы ещё не получили ok, но так как всё равно его
                return;                   // получим, сразу добавим в очередь
            }

            if (logic_reversed[sourcePid]) {  // если ребро логически развёрнуто (то есть на самом деле нам уже не принадлежит)
                edge_from[sourcePid] = false;  // отдаём его, переворачивая на самом деле
                // logic_reversed[sourcePid] = false;  // и сбрасываем флаг (хотя так как ребро стало не нашим, то
                                                       // флаг уже ни на что не влияет -> можно не делать)
                env.send(sourcePid, "ok");  // отвечаем запрашивающему, что "ok, ребро твоё"
                log += "---> send ok\n";
            } else {  // если же ребро не логически перевёрнуто, значит оно ещё нам самим нужно (= мы хотим в cs),
                requests.add(sourcePid);  // но запоминаем, что у нас ребро просили
            }
            return;
            // !!! Заметим, в данном случае мы могли хотеть в cs, но этим запросом нас заставили отдать ребро (которое
            // оказалось логически не нашим) - но ничего страшного: при следующем получении ok (а его мы получим, ведь
            // если бы все ok у нас были, то логически не наши рёбра мы втихаря сделали бы снова нашими и уже
            // вошли в cs) мы вызовем try_to_cs и запроси его обратно.
        }

        if (message.equals("ok")) {  // Если нам ответили ok, значит мы когда-то просили ребро
            assert !edge_from[sourcePid]: "Прислали ok на ребро, которое и так наше" + log;
            edge_from[sourcePid] = true;  // помечаем, что ребро наше
            logic_reversed[sourcePid] = false;  // и тут уже важно указать, что раз ребро только стало нашим, то пока не перевёрнуто
            try_to_cs();  // раз нам прислали ok, значит мы запрашивали рёбра, значит мы хотим в cs -> пытаемся это сделать
        }
    }


    // Функция, которая вызывается у процесса, еогда ему понадобилось войти в cs:
    @Override
    public void onLockRequest() {
        log += "  ! Захотели в cs\n";

        for (int pid = 1; pid <= env.getNumberOfProcesses(); pid ++) {
            if (pid == env.getProcessId())  // проходимся по всем процессам (кроме своего)
                continue;
            if (!edge_from[pid]) {  // если ребро нам не принадлежит, запрашиваем его
                env.send(pid, "need_edge");
                is_requested[pid] = true;
            } else  // иначе (то есть если оно и так наше - и не важно, перевёрнуто ли логически, ведь если что, просто отменим этот переворот)
                is_requested[pid] = false;  // просто ставим флаг, что не запрашивали
        }

        try_to_cs();  // на всякий случай, сразу пытаемся войти (вдруг уже все рёбра наши)
    }


    // Функция, которая вызывается при выходе процесса из cs:
    @Override
    public void onUnlockRequest() {
        log += "  ! Выходим из cs: ...]\n";
        env.unlock();  // сразу выходим из cs
        for (int pid = 1; pid <= env.getNumberOfProcesses(); pid ++) {
            if (pid == env.getProcessId())  // проходимся по всем процессам (кроме своего)
                continue;
            assert edge_from[pid] : "Раз были в cs, значит все рёбра наши были";
            logic_reversed[pid] = true;  // логически переворачиваем все рёбра
        }

        while (!requests.isEmpty()) {  // все запросы на наши рёбра удовлетворяем
            int pid = requests.pop();
            edge_from[pid] = false;  // отдаём ребро (на самом деле его переворачивая)
                                     // (менять logic не нужно, так как он не играет роли для НЕ-наших рёбер)
            env.send(pid, "ok");
            log += "---> send ok\n";
        }
    }
}