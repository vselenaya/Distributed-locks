# Распределённое взаимное исключение

В данном репозитории реализован небольшой проект по курсу "Распределённых вычислений", заключающийся в реализации пяти популярных 
алгоритмов для доступа в критическую секцию (то есть к некоторому разделяемому ресурсу, доступ к которому может иметь только один процесс в каждый
момент времени). Каждая реализация представляет собой код одного процесса (много копий которого составляют распределённую систему), который работает согласно определённому алгоритму:

* Централизованный алгоритм на основе координатора: [`ProcessCentralized.java`](src/main/java/solution/ProcessCentralized.java)
* Алгоритм Лампорта:  [`ProcessLamport.java`](src/main/java/solution/ProcessLamport.java)
* Алгоритм Рикарта и Агравала: [`ProcessRickartAgrawala.java`](src/main/java/solution/ProcessRickartAgrawala.java)
* Алгоритм обедающих философов: [`ProcessPhilosophers.java`](src/main/java/solution/ProcessPhilosophers.java)
* Алгоритм на основе токена: [`ProcessToken.java`](src/main/java/solution/ProcessToken.java)

## Описание задачи

В файле [`MutexProcess.java`](src/main/java/solution/MutexProcess.java) находится описание интерфейса отдельного процесса, 
который реализован в каждом из алгоритмов. 

Тестирующая система запускает код для каждого алгоритма в нескольких процессах, каждому из которых выдан уникальный
идентификатор начинающийся с единицы. Через ссылку на объект [`Environment`](src/main/java/internal/Environment.java) 
каждый процесс может узнать конфигурацию системы и общаться с другими процессами:

* `env.getProcessId()` &mdash; возвращается идентификатор процесса (нумерация с единицы).
* `env.getNumberOfProcesses()` &mdash; возвращает общее число процессов.
* `env.send(destinationPid, message)` &mdash; посылает сообщение `message` процессу с номером `destinationPid` 
(нумерация с единицы).
* `env.lock()` &mdash; должен быть вызван процессом при входе в критическую секцию.
* `env.unlock()` &mdash; должен быть вызван процессом при выходе из критической секции.


## Интерфейс процесса

Тестирующая система имитирует взаимодействие процессов, вызывая методы в следующих случаях:

* `onMessage(sourcePid, message)` &mdash; вызывается при получении сообщения от другого процесса с номером `sourcePid` 
(нумерация с единицы), которое было отправлено этим процессом через `env.send(...)`.
* `onLockRequest()` &mdash; вызывается в случае запроса на вход в критическую секцию.
  Процесс должен инициировать алгоритм
  входа в критическую секцию и, затем вызвать метод `env.lock()`, что определяет начало работы в критической секции.

  Метод `onLockRequest()` не будет повторно вызываться до выхода этого процесса из критической секции.
* `onUnlockRequest()` &mdash; вызывается в случае запроса на выход из критической секции.
  Процесс должен немедленно вызвать метод `env.unlock()` и инициировать алгоритм выхода из критической секции.
  Этот метод будет вызываться только если ранее был осуществлен вход
  в критическую секцию (был вызван `env.lock()`).

## Замечания

* В алгоритме на основе токена гарантируется, что число процессов в системе составляет
  не менее двух;
* В алгоритме Лампорта гарантируется, что сообщения между каждой парой процессов доставляются
  в порядке FIFO;
* В централизованном алгоритме предполагается, что процесс с идентификатором `1` является координатором;
* В алгоритме на основе токена предполагается, что изначально токеном владеет процесс с идентификатором `1`;


## Тестирование

Тестирования реализации происходит путем запуска тестов:
* [`ProcessCentralizedTest.java`](src/test/java/ProcessCentralizedTest.java)
* [`ProcessLamportTest.java`](src/test/java/ProcessLamportTest.java)
* [`ProcessRickartAgrawalaTest.java`](src/test/java/ProcessRickartAgrawalaTest.java)
* [`ProcessTokenTest.java`](src/test/java/ProcessTokenTest.java)
* [`ProcessPhilosophersTest.java`](src/test/java/ProcessPhilosophersTest.java)

Из командной строки: `./gradlew test`

Тест проверяет корректность алгоритма (гарантию взаимного исключения), его прогресса (отсутствие взаимных блокировок),
и замеряет эффективность алгоритма, считая количество передаваемых сообщений.


## Оригинал
Оригнал исходного задания представлен тут: https://github.com/DistSys-MKN/Locks
